{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "form",
  "type": "registry:ui",
  "dependencies": ["@tanstack/solid-form", "solid-js", "tailwind-variants"],
  "registryDependencies": ["button", "label"],
  "files": [
    {
      "path": "registry/jumpwind/ui/form.tsx",
      "content": "import { createFormHookContexts, useStore } from \"@tanstack/solid-form\";\nimport {\n  type ComponentProps,\n  children,\n  createContext,\n  createMemo,\n  createUniqueId,\n  Show,\n  splitProps,\n  useContext,\n} from \"solid-js\";\nimport { cn } from \"@/registry/jumpwind/lib/utils\";\n\nconst { useFieldContext, useFormContext, fieldContext, formContext } =\n  createFormHookContexts();\n\nfunction Form(props: ComponentProps<\"form\">) {\n  const form = useFormContext();\n\n  return (\n    <form\n      onSubmit={(e) => {\n        e.stopPropagation();\n        e.preventDefault();\n        form.handleSubmit();\n      }}\n      {...props}\n    />\n  );\n}\n\nfunction makeFormItem(id: string) {\n  const field = useFieldContext();\n\n  const errors = useStore(field().store, (state) => state.meta.errors);\n  const isTouched = useStore(field().store, (state) => state.meta.isTouched);\n  const submissionAttempts = useStore(\n    field().form.store,\n    (state) => state.submissionAttempts,\n  );\n\n  const error = createMemo<string>(() => {\n    const showError = isTouched() || submissionAttempts() > 0;\n    if (!showError) return undefined;\n    const errs = errors();\n    if (!errs) return;\n\n    const error = errs[0];\n\n    if (typeof error === \"string\") return error;\n    if (typeof error === \"object\") {\n      if (\"message\" in error && typeof error.message === \"string\")\n        return error.message;\n    }\n\n    return String(error);\n  });\n\n  return {\n    id: id,\n    formControlId: `${id}-form-item`,\n    formDescriptionId: `${id}-form-item-description`,\n    formMessageId: `${id}-form-item-message`,\n    error: error,\n  };\n}\n\ntype FormItemContextValue = ReturnType<typeof makeFormItem>;\n\nconst FormItemContext = createContext<FormItemContextValue>();\n\nfunction useFormItem() {\n  const formItem = useContext(FormItemContext);\n  if (!formItem) {\n    throw new Error(\"useFormItemContext must be used within a <FormItem />\");\n  }\n  return formItem;\n}\n\nfunction FormItem(props: ComponentProps<\"div\">) {\n  const [local, rest] = splitProps(props, [\"class\"]);\n\n  const id = createUniqueId();\n  const formItem = makeFormItem(id);\n\n  return (\n    <FormItemContext.Provider value={formItem}>\n      <div\n        data-slot=\"form-item\"\n        class={cn(\"grid gap-2\", local.class)}\n        {...rest}\n      />\n    </FormItemContext.Provider>\n  );\n}\n\nfunction FormLabel(props: ComponentProps<\"label\">) {\n  const [local, rest] = splitProps(props, [\"class\"]);\n  const formItem = useFormItem();\n\n  return (\n    <label\n      data-slot=\"form-label\"\n      bool:data-error={!!formItem.error()}\n      class={cn(\"data-[error=true]:text-destructive\", local.class)}\n      for={formItem.formControlId}\n      {...rest}\n    />\n  );\n}\n\nfunction FormControl(props: ComponentProps<\"div\">) {\n  const [local, rest] = splitProps(props, [\"class\"]);\n\n  const formItem = useFormItem();\n\n  const describedBy = () =>\n    formItem.error() != null\n      ? `${formItem.formDescriptionId} ${formItem.formMessageId}`\n      : `${formItem.formDescriptionId}`;\n\n  return (\n    <div\n      data-slot=\"form-control\"\n      id={formItem.formControlId}\n      aria-describedby={describedBy()}\n      bool:aria-invalid={!!formItem.error()}\n      class={local.class}\n      {...rest}\n    />\n  );\n}\n\nfunction FormDescription(props: ComponentProps<\"p\">) {\n  const [local, rest] = splitProps(props, [\"class\"]);\n\n  const formItem = useFormItem();\n\n  return (\n    <p\n      data-slot=\"form-description\"\n      id={formItem.formDescriptionId}\n      class={cn(\"text-muted-foreground text-sm\", local.class)}\n      {...rest}\n    />\n  );\n}\n\nfunction FormMessage(props: ComponentProps<\"p\">) {\n  const [local, rest] = splitProps(props, [\"class\"]);\n\n  const formItem = useFormItem();\n  const body = children(() => formItem.error() ?? props.children);\n\n  return (\n    <Show when={body()}>\n      {(c) => (\n        <p\n          data-slot=\"form-message\"\n          id={formItem.formMessageId}\n          class={cn(\"text-destructive text-sm\", local.class)}\n          {...rest}\n        >\n          {c()}\n        </p>\n      )}\n    </Show>\n  );\n}\n\nexport {\n  Form,\n  type FormItem,\n  type FormLabel,\n  type FormControl,\n  type FormDescription,\n  type FormMessage,\n  fieldContext,\n  useFieldContext,\n  formContext,\n  useFormContext,\n};\n",
      "type": "registry:ui"
    },
    {
      "path": "registry/jumpwind/lib/utils.ts",
      "content": "import { type Accessor, createMemo, type Ref } from \"solid-js\";\nimport { type ClassValue, cnBase } from \"tailwind-variants\";\n\n/**\n * Combines multiple class strings into one single string.\n *\n * @param classes - The classes to combine.\n * @returns The combined classes.\n */\nexport function cn(...classes: ClassValue[]): string | undefined {\n  return cnBase(classes);\n}\n\nexport type MaybeAccessor<T> = T | (() => T);\n\nexport type MaybeAccessorValue<T extends MaybeAccessor<unknown>> =\n  T extends () => unknown ? ReturnType<T> : T;\n\nexport function access<T extends MaybeAccessor<unknown>>(\n  v: T,\n): MaybeAccessorValue<T> {\n  return typeof v === \"function\" ? v() : (v as MaybeAccessorValue<T>);\n}\n\nexport function chain<Args extends [] | unknown[]>(callbacks: {\n  [Symbol.iterator]: () => IterableIterator<\n    ((...args: Args) => unknown) | undefined\n  >;\n}): (...args: Args) => void {\n  return (...args: Args) => {\n    for (const callback of callbacks) callback?.(...args);\n  };\n}\n\nexport function mergeRefs<T>(...refs: Ref<T>[]): (el: T) => void {\n  return chain(refs as ((el: T) => void)[]);\n}\n\nexport function some(...signals: Accessor<unknown>[]) {\n  return signals.some((signal) => !!signal());\n}\n\n/**\n * Returns a signal with the tag name of the element.\n *\n * @param props.element - The element to get the tag name of.\n * @param props.fallback - The fallback tag name to use if the element is `null`.\n * @returns ```typescript\n * Accessor<string>\n * ```\n */\nexport function createTagName(props: {\n  element: MaybeAccessor<HTMLElement | null>;\n  fallback: string;\n}): Accessor<string> {\n  const tagName = createMemo(\n    () => access(props.element)?.tagName.toLowerCase() ?? props.fallback,\n  );\n\n  return tagName;\n}\n",
      "type": "registry:lib",
      "target": ""
    }
  ]
}
