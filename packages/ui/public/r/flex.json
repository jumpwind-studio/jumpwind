{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "flex",
  "type": "registry:ui",
  "dependencies": ["solid-js", "tailwind-variants"],
  "files": [
    {
      "path": "registry/jumpwind/ui/flex.tsx",
      "content": "import type { ComponentProps } from \"solid-js\";\nimport { mergeProps, splitProps } from \"solid-js\";\nimport { cn } from \"@/registry/jumpwind/lib/utils\";\n\ntype JustifyContent =\n  | \"start\"\n  | \"end\"\n  | \"center\"\n  | \"between\"\n  | \"around\"\n  | \"evenly\";\ntype AlignItems = \"start\" | \"end\" | \"center\" | \"baseline\" | \"stretch\";\ntype FlexDirection = \"row\" | \"col\" | \"row-reverse\" | \"col-reverse\";\n\ninterface FlexProps extends ComponentProps<\"div\"> {\n  direction?: FlexDirection;\n  justify?: JustifyContent;\n  align?: AlignItems;\n  gap?: string | number; // Tailwind gap classes like \"4\", \"8\", etc.\n  w?: number | \"full\" | \"auto\" | `${number}/${number}`; // Tailwind width classes like \"full\", \"1/2\", etc.\n  h?: number | \"full\" | \"auto\" | `${number}/${number}`; // Tailwind height classes like \"full\", \"1/2\", etc.\n}\n\nconst JUSTIFY_CONTENT: Record<JustifyContent, string> = {\n  start: \"justify-start\",\n  end: \"justify-end\",\n  center: \"justify-center\",\n  between: \"justify-between\",\n  around: \"justify-around\",\n  evenly: \"justify-evenly\",\n};\n\nconst ALIGN_ITEM: Record<AlignItems, string> = {\n  start: \"items-start\",\n  end: \"items-end\",\n  center: \"items-center\",\n  baseline: \"items-baseline\",\n  stretch: \"items-stretch\",\n};\n\nconst FLEX_DIRECTION: Record<FlexDirection, string> = {\n  row: \"flex-row\",\n  col: \"flex-col\",\n  \"row-reverse\": \"flex-row-reverse\",\n  \"col-reverse\": \"flex-col-reverse\",\n};\n\nfunction Flex(props: FlexProps) {\n  const defaultedProps = mergeProps(\n    {\n      direction: \"row\",\n      justify: \"between\",\n      align: \"center\",\n      gap: \"4\",\n      w: \"full\",\n      h: \"auto\",\n    } satisfies FlexProps,\n    props,\n  );\n\n  const [local, rest] = splitProps(defaultedProps, [\n    \"class\",\n    \"direction\",\n    \"justify\",\n    \"align\",\n    \"gap\",\n    \"w\",\n    \"h\",\n  ]);\n\n  return (\n    <div\n      class={cn(\n        \"flex w-full\",\n        local.class,\n        FLEX_DIRECTION[local.direction],\n        JUSTIFY_CONTENT[local.justify],\n        ALIGN_ITEM[local.align],\n        local.gap ? `gap-${local.gap}` : \"\",\n        local.w ? `w-${local.w}` : \"\",\n        local.h ? `h-${local.h}` : \"\",\n      )}\n      {...rest}\n    />\n  );\n}\n\nfunction HStack(\n  props: Omit<FlexProps, \"flexDirection\"> & ComponentProps<\"div\">,\n) {\n  const defaultedProps = mergeProps(\n    { direction: \"row\" } satisfies FlexProps,\n    props,\n  );\n\n  return <Flex {...defaultedProps} />;\n}\n\nfunction VStack(\n  props: Omit<FlexProps, \"flexDirection\"> & ComponentProps<\"div\">,\n) {\n  const defaultedProps = mergeProps(\n    { direction: \"col\" } satisfies FlexProps,\n    props,\n  );\n\n  return <Flex {...defaultedProps} />;\n}\n\nexport { Flex, HStack, VStack };\n",
      "type": "registry:ui"
    },
    {
      "path": "registry/jumpwind/lib/utils.ts",
      "content": "import { type Accessor, createMemo, type Ref } from \"solid-js\";\nimport { type ClassValue, cnBase } from \"tailwind-variants\";\n\n/**\n * Combines multiple class strings into one single string.\n *\n * @param classes - The classes to combine.\n * @returns The combined classes.\n */\nexport function cn(...classes: ClassValue[]): string | undefined {\n  return cnBase(classes);\n}\n\nexport type MaybeAccessor<T> = T | (() => T);\n\nexport type MaybeAccessorValue<T extends MaybeAccessor<unknown>> =\n  T extends () => unknown ? ReturnType<T> : T;\n\nexport function access<T extends MaybeAccessor<unknown>>(\n  v: T,\n): MaybeAccessorValue<T> {\n  return typeof v === \"function\" ? v() : (v as MaybeAccessorValue<T>);\n}\n\nexport function chain<Args extends [] | unknown[]>(callbacks: {\n  [Symbol.iterator]: () => IterableIterator<\n    ((...args: Args) => unknown) | undefined\n  >;\n}): (...args: Args) => void {\n  return (...args: Args) => {\n    for (const callback of callbacks) callback?.(...args);\n  };\n}\n\nexport function mergeRefs<T>(...refs: Ref<T>[]): (el: T) => void {\n  return chain(refs as ((el: T) => void)[]);\n}\n\nexport function some(...signals: Accessor<unknown>[]) {\n  return signals.some((signal) => !!signal());\n}\n\n/**\n * Returns a signal with the tag name of the element.\n *\n * @param props.element - The element to get the tag name of.\n * @param props.fallback - The fallback tag name to use if the element is `null`.\n * @returns ```typescript\n * Accessor<string>\n * ```\n */\nexport function createTagName(props: {\n  element: MaybeAccessor<HTMLElement | null>;\n  fallback: string;\n}): Accessor<string> {\n  const tagName = createMemo(\n    () => access(props.element)?.tagName.toLowerCase() ?? props.fallback,\n  );\n\n  return tagName;\n}\n",
      "type": "registry:lib",
      "target": ""
    }
  ]
}
