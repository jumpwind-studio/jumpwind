import * as FileSystem from "@effect/platform/FileSystem";
import * as Path from "@effect/platform/Path";
import * as BunContext from "@effect/platform-bun/BunContext";
import * as BunRuntime from "@effect/platform-bun/BunRuntime";
import * as Console from "effect/Console";
import * as Effect from "effect/Effect";
import * as Schema from "effect/Schema";
import registry from "../registry.json" with { type: "json" };
import { Registry, type RegistryItem } from "../src/registry/schema.js";

const buildRegistryItem = Effect.fn("scripts/build-registry-item")(function* (
  item: RegistryItem,
) {
  const path = yield* Path.Path;

  const resolveFiles = item.files?.map((file) => `registry/${file.path}`);
  if (!resolveFiles) {
    return {};
  }

  const type = item.type.split(":")[1];
  const sourceFilename = "";

  const hasFiles = item.files?.length;
  const hookPath = hasFiles
    ? `@/registry/${item.files[0]?.path}`
    : `@/registry/${registry.name}/${type}/${item.name}`;

  return {
    [item.name]: {
      name: item.name,
      type: item.type,
      registryDependencies: item.registryDependencies,
      files: item.files?.map((file) => {
        const filePath = `registry/${file.path}`;
        return {
          path: filePath,
          type: file.type,
          target: file.target ?? "",
          resolvedPath: path.resolve(filePath),
        };
      }),

      component: `Solid.lazy(() => import('${hookPath}'))`,
      source: sourceFilename,
    } as const,
  };
});

const REGISTRY_LOCATION = "./registry/jumpwind/ui/";

const buildRegistryFile = Effect.fn("scripts/build-registry")(function* (
  registry: Registry,
) {
  yield* Effect.logInfo(`Building ${registry.name}`);

  const path = yield* Path.Path;
  const fs = yield* FileSystem.FileSystem;

  const registryPath = path.join(process.cwd(), REGISTRY_LOCATION);
  const resolvedPath = path.resolve(registryPath);
  const registryFiles = yield* fs.readDirectory(resolvedPath);
  yield* Effect.logInfo(`Found ${registryFiles.length} files`);
  const allFiles = registryFiles.map((file) => path.join(resolvedPath, file));
  const oneFile = yield* fs.readFileString(allFiles[0]!);
  // yield* Effect.logInfo(oneFile);
  let hasAllDeps = false;
  let onImport = true;
  const deps: string[] = [];
  const regex = /from\s+"([^"]*)"/g;
  for (let line of oneFile.split("\n")) {
    yield* Effect.logInfo(line);
    if (!line.includes("import") && !onImport) {
      hasAllDeps = true;
      break;
    }
    if (line.includes("import")) {
      yield* Effect.logInfo("found an import");
      onImport = true;
    }
    if (onImport && line.includes("from")) {
      yield* Effect.logInfo("found a from");
      const match = regex.exec(line);
      line = line.replaceAll('"', "");
      deps.push(line);
      onImport = false;
    }
  }
  yield* Effect.logInfo(deps);

  // const items = registry.items.filter(Boolean).map(buildRegistryItem);

  // const lines = [
  //   "/* eslint-disable */",
  //   "//",
  //   "// @ts-nocheck",
  //   "// This file is autogenerated by @/scripts/build-registry.ts",
  //   "// Do not edit this file directly.",
  //   'import * as Solid from "solid-js"',
  //   "",
  //   "export const Index: Record<string, any> = {",
  //   JSON.stringify(registry.items, null, 2),
  //   "}",
  // ].join("\n");
  // yield* Effect.logInfo(lines);
});

const persistRegistry = Effect.fn("scripts/save-registry")(function* (
  registryData: any,
) {
  const fs = yield* FileSystem.FileSystem;
  const path = yield* Path.Path;

  const outputPath = path.join(process.cwd(), "__registry__/index.tsx");

  // Remove existing file (equivalent to rimraf.sync)
  const alreadyExists = yield* fs.exists(outputPath);
  if (alreadyExists) {
    fs.remove(outputPath);
  }

  // Save data to file
  yield* fs.writeFileString(outputPath, registryData);
});

const program = Effect.gen(function* () {
  yield* Console.log("ðŸ’½ Building registry...");

  // Validate the registry schema
  const validatedRegistry = yield* Schema.decodeUnknown(Registry)(registry);

  // Build the registry file
  yield* buildRegistryFile(validatedRegistry);

  yield* Console.log("âœ… Done!");
}).pipe(
  Effect.catchAll((error) =>
    Effect.gen(function* () {
      yield* Console.error(error);
      yield* Effect.fail(new Error("Build failed"));
    }),
  ),
);

// Run the program with Bun context
const main = program.pipe(Effect.provide(BunContext.layer));

BunRuntime.runMain(main);
